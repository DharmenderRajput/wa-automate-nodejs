"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7657],{2060:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=r(4848),t=r(8453);const o={},a="Error Handling",c={id:"how-to/handle-errors",title:"Error Handling",description:"Keep your promises!",source:"@site/docs/how-to/handle-errors.md",sourceDirName:"how-to",slug:"/how-to/handle-errors",permalink:"/docs/how-to/handle-errors",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/how-to/handle-errors.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Group",permalink:"/docs/how-to/groups"},next:{title:"Handle Incoming Call",permalink:"/docs/how-to/incoming-calls"}},i={},l=[{value:"Keep your promises!",id:"keep-your-promises",level:2},{value:"Error handling on <code>create</code>",id:"error-handling-on-create",level:2},{value:"Manage page errors",id:"manage-page-errors",level:2},{value:"Kill the session",id:"kill-the-session",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h2,{id:"keep-your-promises",children:"Keep your promises!"}),"\n",(0,s.jsxs)(n.p,{children:["Treat all ",(0,s.jsx)(n.code,{children:"client"})," methods as promises. Therefore make sure to await them and wrap them in ",(0,s.jsx)(n.code,{children:"try/catch"})," blocks"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"    client.onMessage(async message => {\n        try{\n            //respond with 'Hi!'\n            await client.sendText(message.from, 'Hi!');\n        } catch(error){\n            console.log(error);\n        }\n    })\n\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"error-handling-on-create",children:["Error handling on ",(0,s.jsx)(n.code,{children:"create"})]}),"\n",(0,s.jsx)(n.p,{children:"The [[create]] method itself is a promise so you can handle errors using a try catch block here also from which you can choose to try again or exit the process."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function start(client){\n    ...\n}\n\nasync function launch(){\n    try{\n        const client = await create();\n        await start(client);\n    } catch(error){\n        console.log(errror)\n    }\n}\n\nlaunch();\n\n"})}),"\n",(0,s.jsx)(n.p,{children:'Alternatively, you can set the client "start" function (the function that consumes the client after it has been created) as a config variable [[restartOnCrash]], allowing the process itself to restart/retry if there are any issues. Be careful with this as it may lead to an endless loop.'}),"\n",(0,s.jsx)(n.p,{children:"You can also use [[logConsole]] (logs all browser console output) or just [[logConsoleErrors]] (only logs browser errors) to better debug issues."}),"\n",(0,s.jsx)(n.p,{children:"Setting [[killProcessOnBrowserClose]] to true will kill the whole node process upon any critical browser issue (maybe the browser runs out of memory and crashes, this option will kill the process)."}),"\n",(0,s.jsxs)(n.p,{children:["This is useful if you have a n orchestrator process that restarts processes. (e.g ",(0,s.jsx)(n.a,{href:"https://pm2.keymetrics.io/",children:"pm2"})," or a ",(0,s.jsx)(n.a,{href:"https://docs.docker.com/config/containers/start-containers-automatically/#:~:text=Restart%20policy%20details,-Keep%20the%20following&text=A%20restart%20policy%20only%20takes,going%20into%20a%20restart%20loop.",children:"docker restart policy"}),")"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function start(client){\n    ...\n}\n\nasync function launch(){\n    try{\n        const client = await create({\n            //sets restartOnCrash to the above `start` function\n            restartOnCrash: start,\n\n            //log all browser console output\n            logConsole: true,\n\n            //or just browser errors\n            logConsoleErrors: true,\n\n            //kill the process if the browser crashes/is closed manually\n            killProcessOnBrowserClose: true\n        });\n        await start(client);\n    } catch(error){\n        console.log(error)\n    }\n}\n\nlaunch();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"manage-page-errors",children:"Manage page errors"}),"\n",(0,s.jsxs)(n.p,{children:["Since this project is built upon puppeteer, you can access the ",(0,s.jsx)(n.a,{href:"https://pptr.dev/#?product=Puppeteer&version=v2.0.0&show=api-class-page",children:"Puppeteer Page"})," instance by referencing ",(0,s.jsx)(n.code,{children:"client.getPage()"}),", and then therefore you can listen to any errors on the page like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"client.getPage().on('error', _=>{\n...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"kill-the-session",children:"Kill the session"}),"\n",(0,s.jsx)(n.p,{children:"As of v1.6.6^ you can now kill the session when required. Best practice is to manage trycatch-es yourself and kill the client on catch."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"try{\n...\nawait client.sendMessage(...\n...\n} catch(error){\nclient.kill();\n//maybe restart the session then\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var s=r(6540);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);